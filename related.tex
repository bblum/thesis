%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Systematic exploration is a relatively young approach to concurrency verification.
Recent work has focused on theoretical aspects of the technique, on distributed systems, and in userspace in general.
Other work has focused on kernel verification apart from systematic exploration, using techniques such as data race detection and formal model verification.
Still other efforts are for testing and verification techniques that are orthogonal to systematic exploration and kernel-level testing entirely.
Here we discuss related work in all three categories.

Landslide distinguishes itself from related systematic testing tools in its field as more of an exploratory work, presenting techniques to make systematic testing compatible with kernel-level code; less so as a development on the core testing approach itself.

\subsection{Systematic Exploration}

Dynamic Partial Order Reduction (DPOR) \cite{dpor,sdpor,dbug-retreat} is an algorithm for reducing the state space of ``all possible thread interleavings'' by identifying independent thread transitions and pruning the redundant state spaces that result from interleaving those transitions. Landslide makes generous use of the DPOR algorithm.

dBug\cite{dbug-ssv} is a systematic testing tool which makes use of DPOR. It focuses on multithreaded userspace applications, identifying when to preempt by interposing on \texttt{libc} library calls. It uses a message-passing model for inter-thread communication and for establishing a happens-before relationship between transitions. The dBug project heavily inspired the development of Landslide.

CHESS\cite{chess} is another userspace systematic testing tool. They explore the insight that many races require very few forced preemptions to uncover, and develop a search strategy which prioritises thread interleavings with fewer preemptions. Landslide does not (yet) make use of this strategy, though we did find a related insight which we discuss in Section~\ref{sec:future-backwards}.

There are also several tools, such as MaceMC\cite{macemc} and MODIST\cite{modist}, which provide systematic testing frameworks for networked and distributed applications.

DeMeter\cite{demeter} is a more recent tool for systematic exploration that introduces Dynamic Interface Reduction as a strategy for constraining the size of the state space, which means targetting the testing technique on only one component of the program at a time. Landslide makes use of the same general concept in its user interface (Section~\ref{sec:using}) - it provides the user with options to constrain decision point identification to certain subsets of the kernel.

\subsection{Kernel-level Verification}

\cite{racepro}
\cite{sel4}
\cite{datacollider}
\cite{carburizer}

\subsection{Orthogonal Testing Techniques}

Research in dynamic verification has also seen other techniques apart from systematic exploration.

Symbolic execution\cite{symbolic,symbolic-disks} is a technique for testing programs by abstractly interpretating symbols and operations within a program, rather than directly executing its compiled code, which grants the ability to analyse conditional statements and cause-effect relationships among certain code paths.
Tools such as KLEE\cite{klee} and projects such as Automated Exploit Generation\cite{aeg} demonstrate the effectiveness of symbolic execution in dynamic verification.
We discuss the possibility of integrating symbolic execution into a testing framework such as Landslide in Section~\ref{sec:future-new}.

Deterministic multithreading is a different technique for dealing with concurrency bugs which focuses on avoiding them when running production code rather than trying to expose them during testing. Deterministic multithreading tools, such as Kendo\cite{kendo}, PEREGRINE\cite{peregrine}, and DThreads\cite{dthreads}, analyse the execution of a concurrent system and compute particular scheduling patterns which will not produce buggy behaviours, and force the system to follow those schedules while maintaining good parallel performance.
Deterministic multithreading serves a different purpose than systematic exploration; it aims to ensure that code already running in the real world does not encounter concurrency bugs even though they might exist, while our goals are instead to uncover such bugs and help fix them beforehand.

% vim: ft=tex
