%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design and Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Components of Landslide}

Here we briefly describe each major component of Landslide. % TODO: provide a figure landslide.png

\subsubsection{Kernel Instrumentation}
\label{sec:components-kern}
% TODO

\subsubsection{Scheduling}
\label{sec:components-sched}

% TODO

\subsubsection{Memory Tracking}
\label{sec:components-memory}

Landslide maintains a mirror image of the guest kernel's dynamic allocation heap, so it can know at any point what memory ranges are allocated and what ranges used to be allocated but now are freed. This set is updated each time the guest kernel calls \texttt{malloc} or \texttt{free}.

Landslide also maintains a set of shared memory accesses made since the last decision point. Whenever the guest kernel accesses memory in its heap or in its global data regions, Landslide adds the address of the access to the set, with a flag indicating whether it was a read or a write. (If the address was already present, and the recorded access was a read and the current access is a write, we upgrade the recorded access to a write. Otherwise if the address was already present, we do nothing.)

Landslide ignores shared memory accesses from the kernel's dynamic allocator itself, and it also ignores shared memory accesses from the components of the kernel's scheduler which run every transition (Section~\ref{sec:por-independence}).

When Landslide reaches a decision point, this accumulated set is copied in the decision tree (Section~\ref{sec:components-explore}), and reset to empty before continuing execution.

\subsubsection{The Arbiter}
\label{sec:components-arbiter}

The arbiter identifies points during execution should count as decision points. The selection is mainly controlled by the user, during the annotation and configuration process, but it also automatically identifies {\em voluntary reschedules}, which comprise the ``minimal necessary set'' of decision points.

A voluntary reschedule is identified when:
\begin{itemize}
	\item The previously-running thread entered the context switcher without first entering the timer interrupt handler,
\end{itemize}

and {\em any one} of the following:
\begin{itemize}
	\item The currently-running thread was handling a timer interrupt, and exits the {\em timer interrupt handler}.
	\item The currently-running thread was not handling a timer interrupt, and exits the {\em context switcher}.
	\item The currently-running thread was {\em just forked} (i.e, it has never run before), and hence may never exit either the timer handler or context switcher.
\end{itemize}

It is always necessary to identify a decision point during a voluntary reschedule, to maintain the invariant that each transition between decision points is comprised of the execution of only one thread.

In future work (Section~\ref{sec:future-new}), the arbiter may also automatically identify extra decision points, such as on conflicting shared memory accesses.

\subsubsection{The Explorer}
\label{sec:components-explore}

The explorer maintains a representation of the current branch of the decision tree. It is responsible for checkpointing at each decision point, deciding at the end of the test which branch of the tree to execute next (i.e., selecting which decision point should have been decided differently), and backtracking to appropriate points in the test's execution.

At each decision point, Landslide creates a new node in the decision tree. It stores the TID of the thread that was chosen, the state of the scheduler (what threads are on the runqueue), the state of the heap and the accumulated set of shared memory accesses, and a stack trace of the thread that was running.

\subsubsection{Test Lifecycle}
\label{sec:components-test}
% Talk about the test lifecycle - pre-readline; pre-test-start; etc.
% Talk about the population tricks.
% Talk about how we want idle/shell's wait() to be part of the test.

\subsection{On Simics}

Landslide is implemented as a module for Simics\cite{simics}. When running the kernel, Simics calls into Landslide once every time the kernel executes an instruction or performs a memory read or write. Landslide uses this information, in conjunction with the user-provided instrumentation, to maintain its internal representations of the state of the guest kernel.

Landslide also makes use of Simics ``bookmarks'' to checkpoint and restore the execution state at decision points during the test.

\subsection{Thread Scheduling}

\begin{algorithm*}[t!]
	\small
	\label{alg:inflight}
	\begin{algorithmic}
		\State {\em Global scheduler state.}
		\State bool schedule\_in\_flight;
		\State int target\_tid;
		\\
		\State {\em Per-thread state. (Updated elsewhere.)}
		\State bool in\_timer\_handler, in\_context\_switch;
		\State int current\_tid;
		\\
		\Function{scheduler\_update}{int pc}
			\If{schedule\_in\_flight}
				\State {\sc assert}(in\_timer\_handler || in\_context\_switch);
				\If { {\sc kernel\_exiting\_timer}(pc) || (!handling\_timer \&\& {\sc kernel\_exiting\_context\_switch}(pc))}
					\State {\em The kernel has just finished rescheduling and is about to resume normal thread execution.}
					\If {current\_tid != target\_tid}
						\State {\em The kernel switched to an undesirable thread. Keep the schedule operation ``in-flight''.}
						\State {\sc cause\_timer\_interrupt}();
					\Else
						\State {\em The in-flight schedule is ``landing''.}
						\State schedule\_in\_flight $\gets$ false;
					\EndIf
				\EndIf
			\ElsIf{{\sc need\_to\_preempt}()}
				\State target\_tid $\gets$ {\sc choose\_new\_thread}();
				\State schedule\_in\_flight $\gets$ true;
				\State {\sc cause\_timer\_interrupt}();
			\EndIf
		\EndFunction
	\end{algorithmic}
	\caption{The scheduling algorithm. This procedure for updating the scheduler's state is executed once per instruction, with a corresponding value for \texttt{pc} (the program counter) each time. The predicates on \texttt{pc} are part of the kernel instrumentation (Section~\ref{sec:components-kern}).}
\end{algorithm*}

In Landslide's view of the world, timer interrupts are the only source of nondeterminism for the guest kernel, and controlling when they occur theoretically allows for complete control over the concurrent behaviour of the test case. However, it is more useful to view the concurrent behaviour with a higher-level abstraction, in terms of the set of runnable threads and the ability to preempt the currently-running thread with any different runnable one.

Landslide's scheduling technique, called the {\em schedule in-flight}, involves successive triggering of timer interrupts to trigger context switches until the desired thread begins to run. Algorithm~\ref{alg:inflight} shows how Landslide makes this happen.

One alternative simpler method would be, when triggering a timer interrupt, to tell the guest kernel explicitly which thread should be run next. This would require the kernel programmer to write extra code in their timer handler and/or context switcher. We chose the ``in-flight'' approach instead, because it does not require additional kernel modifications.

\subsection{Identifying Bugs}
\label{sec:techniques-bugs}

% A healthy dose of snark.
Without a formal specification of the internals of the guest kernel's implementation\cite{sel4}, it is of course impossible to identify both soundly and completely when a behaviour that constitutes a ``bug'' arises during a test case's execution.
In order to identify when the guest kernel has done something incorrect, Landslide performs several different types of checks, some accurate but noncomprehensive, and some heuristic-based.

Landslide's bug reporting is false-negative oriented, meaning that it does not check for suspicious behaviours that might indicate underlying bugs, so it may report that it found no bugs even if some existed. If Landslide does report a bug, though, it is almost certainly correct (except in cases as listed below).

\subsubsection{Accurate Bug-Detection Conditions}

\begin{enumerate}
	\item {\bf Kernel panic bugs.} If the kernel invoked \texttt{panic}, it detected its own bug, and Landslide need do nothing but report it.
	\item {\bf Use-after-free bugs.} Whenever the kernel accesses memory in the heap (when not in the dynamic allocator itself), Landslide verifies that the address is within an allocated range. If not, Landslide proclaims the access to be illegal.\footnote{In the same way, Landslide also detects calls to \texttt{free} on blocks that were already freed or never allocated at all.}
	\item {\bf Deadlock bugs.} If Landslide finds no runnable threads on the runqueue\footnote{Except for idle, if it exists.}, or if it detects a cycle of threads blocked on each other, it declares that the kernel has deadlocked.
\suspend{enumerate}

\subsubsection{Uncertain Bug-Detection Conditions}

\resume{enumerate}
	\item {\bf Memory leak bugs.} Landslide records the state of the heap before the test case begins, and compares it to the state of the heap after the test case ends. If memory allocated during the test was not freed, Landslide assumes that it was leaked.
		(Some kernel designs may legitimately behave this way, so this bug-check may be disabled when testing such kernels.)\footnote{There is, of course, much room for improvement in this metric, but it is not part of the research contribution.}
	\item {\bf Infinite loop bugs.} Landslide judges whether the kernel has entered an infinite loop by comparing the current state of the decision tree to past executions of the same test case.
	\begin{itemize}
		\item While exploring the decision tree, Landslide computes the average number of instructions executed between two consecutive decision points. If at any point the current number of instructions executed since the most recent decision point exceeds this average times a constant factor (arbitrarily chosen to be 2000), Landslide assumes the kernel must have gotten stuck in an infinite loop.
		\item Landslide also computes the average number of decision points in each branch of the decision tree (the average ``branch depth''). If the depth of the current branch ever exceeds this average times a constant factor (arbitrarily chosen to be 20), Landslide assumes the kernel must have gotten stuck in an infinite loop.
	\end{itemize}
\end{enumerate}

\subsection{Partial-Order Reduction}
\label{sec:techniques-por}

We make use of Dynamic Partial-Order Reduction, the state-space pruning algorithm presented in \cite{dpor}. Here we discuss the specifics of implementing DPOR in our environment.

\subsubsection{Happens-Before Relation}
% TODO

\subsubsection{Memory Independence Relation}
\label{sec:por-independence}
The independence relation expresses which transitions do not read-and-write or write-and-write to the same shared memory addresses.

\begin{itemize}
	\item {\bf Always-accessed memory locations.} % talk about ignoring runqueue accesses, etc TODO
	\item {\bf Freed memory poisoning.}
		A use-after-free bug happens whenever one thread accesses an address within an allocated block that another thread previously freed. Even if no other code makes a conflicting access to the same address after the \texttt{free}, the C idiom says that accessing dynamically-allocated memory after it has been freed is illegal no matter what.

		Hence, even if the second thread that freed the block never accesses the particular address that the first thread used, the second thread's \texttt{free} still logically conflicts with the first thread's access. Landslide addresses this by treating every call to \texttt{free} as a {\em write} access to every address within the freed block when computing shared memory conflicts.
\end{itemize}

\subsubsection{Coarse Granularity}
% talk about the all-ancestors vs induction thing TODO

\subsection{Debugging Feedback}

% TODO: provide a figure

In its unique position of control over when the kernel gets preempted and which thread gets scheduled at each context-switch, Landslide has the capability to provide the user with detailed information about a test case's execution.
When Landslide determines that a bug was found, it immediately aborts exploration of the decision tree, and prints a {\em decision trace} - a comprehensive report of the particular interleaving of thread transitions that caused the bug to appear.

The decision trace explains each preemption or voluntary reschedule in the interleaving: which thread used to be running, which thread was chosen to run instead, and the stack trace of the former thread at the point from which it was switched away.

Landslide also prints the stack trace of the currently-running thread at the point where the bug was found, and (optionally) drops the user into the Simics debugging prompt. Depending on the nature of the bug found, Landslide also provides more detailed information:

\begin{enumerate}
	\item If the kernel has panicked, Landslide prints the message used in the panic/assertion.
	\item If a use-after-free bug is found, Landslide prints information about the most-recently-freed chunk containing the accessed address: the stack trace and TID both for when it was allocated and freed.
	\item If deadlock is detected, Landslide prints the cycle of TIDs that are blocked on each other.\footnote{This currently only works when using the annotations for yielding mutexes, though it is not difficult to implement more generally.}
	\item If a memory leak is suspected, Landslide prints how many bytes bigger the heap is after the test ended than when the test began.\footnote{Future feature: Printing when-allocated stack traces for each suspicious heap chunk.}
	\item If an infinite loop is suspected, depending on which heuristic was triggered, Landslide prints either the number of instructions since the last decision point (and the previous average) or the current branch depth (and the previous average).
\end{enumerate}

Landslide can also provide other useful information, even in cases where it did not find bugs, to help with the user's process of configuring decision points. Instead of exploring alternative interleavings, it can stop execution after the first interleaving and print out the set of decision points that were identified, along with the shared memory conflicts and happens-before relations for pairs of transitions between the decision points.
